export async function getOpenAIMove(
  game,
  openAIKey,
  moveHistory,
  capturedPieces,
  logCallback
) {
  logCallback("Starting getOpenAIMove function");
  const apiUrl = "https://api.openai.com/v1/chat/completions";
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${openAIKey}`,
  };

  const maxAttempts = 3;
  let attempts = 0;

  while (attempts < maxAttempts) {
    attempts++;
    logCallback(`Attempt ${attempts} of ${maxAttempts}`);

    const legalMoves = game.moves({ verbose: true });
    const legalMovesStr = legalMoves
      .map((move) => `${move.from}${move.to}`)
      .join(", ");

    const recentMoves = moveHistory.slice(-10);

    // Legal moves: ${legalMovesStr}
    const prompt = `You are acting as Magnus Carlsen. As an expert in chess, analyze the following chess position and suggest the best move for next turn as ${
      game.turn() === "w" ? "White" : "Black"
    }. 
    Current position (FEN): ${game.fen()} lowercase for black and uppercase for white.
    Recent moves (last 10): ${recentMoves.join(", ")}
    Captured pieces: White: ${capturedPieces.w.join(
      ", "
    )}, Black: ${capturedPieces.b.join(", ")}
    Provide your answer in the format 'bestmove e2e4' where e2e4 represents the suggested next move. Ensure the move is one of the legal moves listed above. Use all you can use to win the game as your role!!! Your goal is to checkmate.
    your answer should strictly follows the format. Don't answer anything else.
    ---
    ${
      attempts > 1
        ? "The previous suggestion was invalid. Please provide a different, valid move."
        : ""
    }`;

    logCallback("Prompt for OpenAI:", prompt);

    const body = JSON.stringify({
      model: "gpt-4-turbo",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.7,
      max_tokens: 3000,
    });

    try {
      logCallback("Sending request to OpenAI API");
      const response = await fetch(apiUrl, { method: "POST", headers, body });
      const data = await response.json();
      logCallback("Received response from OpenAI API:", JSON.stringify(data));

      if (data.error) {
        throw new Error(`OpenAI API error: ${data.error.message}`);
      }

      const content = data.choices[0].message.content;
      logCallback("OpenAI response content:", content);

      // Expanded regex to match various formats
      const moveMatch = content.match(
        /(?:best ?move|move|play)\s*:?\s*([a-h][1-8])[-\s]?([a-h][1-8])/i
      );

      if (moveMatch) {
        const [, from, to] = moveMatch;
        logCallback("Parsed move:", JSON.stringify({ from, to }));

        // Validate the move
        const move = game.move({ from, to, promotion: "q" });
        if (move) {
          game.undo(); // Undo the move to keep the game state unchanged
          return { from, to };
        } else {
          logCallback(
            "Invalid move generated by OpenAI:",
            JSON.stringify({ from, to })
          );
          logCallback("Legal moves:", legalMovesStr);
        }
      } else {
        logCallback("Failed to parse OpenAI response. Full content:", content);

        // Attempt to extract any sequence that looks like a chess move
        const possibleMoves = content.match(/[a-h][1-8][a-h][1-8]/g);
        if (possibleMoves) {
          logCallback(
            "Possible moves found in response:",
            JSON.stringify(possibleMoves)
          );
          // Try these possible moves
          for (const moveStr of possibleMoves) {
            const [from, to] = [moveStr.slice(0, 2), moveStr.slice(2)];
            const move = game.move({ from, to, promotion: "q" });
            if (move) {
              game.undo();
              logCallback(
                "Valid move found from possible moves:",
                JSON.stringify({ from, to })
              );
              return { from, to };
            }
          }
        }
      }
    } catch (error) {
      logCallback("Error in getOpenAIMove:", error.message);
    }
  }

  logCallback(
    "Failed to generate a valid move after " + maxAttempts + " attempts"
  );
  return null;
}
